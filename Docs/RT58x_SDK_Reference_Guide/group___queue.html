<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rafael RT58x  SDK: Queue API Definition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.BMP"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rafael RT58x  SDK
   &#160;<span id="projectnumber">v1.9.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queue API Definition</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqueue__elem.html">queue_elem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqueue__t.html">queue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue instance. All manipulation of struct internals should be left to the queue module.  <a href="structqueue__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga523141385b8affffe68b9052f9d86aed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga523141385b8affffe68b9052f9d86aed">QUEUE_ITERATOR_BEGIN</a>(p_QUEUE)</td></tr>
<tr class="separator:ga523141385b8affffe68b9052f9d86aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0b3a8c99273f88f34ca4be6f52261c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga4c0b3a8c99273f88f34ca4be6f52261c">QUEUE_ITERATOR_END</a>(p_QUEUE)</td></tr>
<tr class="separator:ga4c0b3a8c99273f88f34ca4be6f52261c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga721d59d18eb4ecd0e164992274f99729"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga721d59d18eb4ecd0e164992274f99729">QUEUE_FOREACH</a>(p_QUEUE,  ITERATOR)</td></tr>
<tr class="separator:ga721d59d18eb4ecd0e164992274f99729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf649c5b074bc8e31597b73424d5e7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#gabf649c5b074bc8e31597b73424d5e7ee">queue_init</a> (<a class="el" href="structqueue__t.html">queue_t</a> *p_queue)</td></tr>
<tr class="separator:gabf649c5b074bc8e31597b73424d5e7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f85aea4c49c1e0d9c63bd2801c9c99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#gaf9f85aea4c49c1e0d9c63bd2801c9c99">queue_push</a> (<a class="el" href="structqueue__t.html">queue_t</a> *p_queue, <a class="el" href="structqueue__elem.html">queue_elem_t</a> *p_elem)</td></tr>
<tr class="separator:gaf9f85aea4c49c1e0d9c63bd2801c9c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246a80aa4f6bba745b2fe186f904020c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqueue__elem.html">queue_elem_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga246a80aa4f6bba745b2fe186f904020c">queue_pop</a> (<a class="el" href="structqueue__t.html">queue_t</a> *p_queue)</td></tr>
<tr class="separator:ga246a80aa4f6bba745b2fe186f904020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3c69b67db07c577a680294a7ee2a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structqueue__elem.html">queue_elem_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga5d3c69b67db07c577a680294a7ee2a58">queue_peek</a> (const <a class="el" href="structqueue__t.html">queue_t</a> *p_queue)</td></tr>
<tr class="separator:ga5d3c69b67db07c577a680294a7ee2a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d68de14bc06afa6ca37363b5451896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga30d68de14bc06afa6ca37363b5451896">queue_merge</a> (<a class="el" href="structqueue__t.html">queue_t</a> *p_dst, <a class="el" href="structqueue__t.html">queue_t</a> *p_src)</td></tr>
<tr class="separator:ga30d68de14bc06afa6ca37363b5451896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf6016887c7c7e3cc288f81893fc02c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#gabf6016887c7c7e3cc288f81893fc02c9">queue_iterator_elem_remove</a> (<a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> *p_it)</td></tr>
<tr class="separator:gabf6016887c7c7e3cc288f81893fc02c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220df2b2c40d479e44f22cc72a043493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga220df2b2c40d479e44f22cc72a043493">queue_iterator_elem_insert</a> (<a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> *p_it, <a class="el" href="structqueue__elem.html">queue_elem_t</a> *p_elem)</td></tr>
<tr class="separator:ga220df2b2c40d479e44f22cc72a043493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1560182acc41d1597f4f15c6b64d5413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queue.html#ga1560182acc41d1597f4f15c6b64d5413">queue_iterator_iterate</a> (<a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> *p_it)</td></tr>
<tr class="separator:ga1560182acc41d1597f4f15c6b64d5413"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Define Queue definitions, structures, and functions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga721d59d18eb4ecd0e164992274f99729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga721d59d18eb4ecd0e164992274f99729">&#9670;&nbsp;</a></span>QUEUE_FOREACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QUEUE_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_QUEUE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ITERATOR&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> ITERATOR = <a class="code" href="group___queue.html#ga523141385b8affffe68b9052f9d86aed">QUEUE_ITERATOR_BEGIN</a>(p_QUEUE); \</div>
<div class="line">         (*((ITERATOR).pp_elem) != NULL);                                \</div>
<div class="line">         queue_iterator_iterate(&amp;ITERATOR))</div>
<div class="ttc" id="agroup___queue_html_ga523141385b8affffe68b9052f9d86aed"><div class="ttname"><a href="group___queue.html#ga523141385b8affffe68b9052f9d86aed">QUEUE_ITERATOR_BEGIN</a></div><div class="ttdeci">#define QUEUE_ITERATOR_BEGIN(p_QUEUE)</div><div class="ttdef"><b>Definition:</b> util_queue.h:113</div></div>
<div class="ttc" id="astructqueue__elem__iterator__t_html"><div class="ttname"><a href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a></div><div class="ttdef"><b>Definition:</b> util_queue.h:102</div></div>
</div><!-- fragment --><p>Iterates over a queue like for loop.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe. It should only be used on queues that operate in a single IRQ level.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QUEUE</td><td>Queue to iterate over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ITERATOR</td><td>Iterator name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga523141385b8affffe68b9052f9d86aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523141385b8affffe68b9052f9d86aed">&#9670;&nbsp;</a></span>QUEUE_ITERATOR_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QUEUE_ITERATOR_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_QUEUE</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                   \</div>
<div class="line">        .p_queue = (p_QUEUE),           \</div>
<div class="line">        .pp_elem = &amp;(p_QUEUE)-&gt;p_front, \</div>
<div class="line">        .repeat = <span class="keyword">false</span>                 \</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Iterator init value for the beginning of the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QUEUE</td><td>Queue to iterate over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c0b3a8c99273f88f34ca4be6f52261c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0b3a8c99273f88f34ca4be6f52261c">&#9670;&nbsp;</a></span>QUEUE_ITERATOR_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QUEUE_ITERATOR_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_QUEUE</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                   \</div>
<div class="line">        .p_queue = (p_QUEUE),           \</div>
<div class="line">        .pp_elem = &amp;(p_QUEUE)-&gt;p_back, \</div>
<div class="line">        .repeat = <span class="keyword">false</span>                 \</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Iterator init value for the end of the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QUEUE</td><td>Queue to iterate over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabf649c5b074bc8e31597b73424d5e7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf649c5b074bc8e31597b73424d5e7ee">&#9670;&nbsp;</a></span>queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>p_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a queue instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_queue</td><td>Pointer to an uninitialized queue instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga220df2b2c40d479e44f22cc72a043493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220df2b2c40d479e44f22cc72a043493">&#9670;&nbsp;</a></span>queue_iterator_elem_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_iterator_elem_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>p_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue__elem.html">queue_elem_t</a> *&#160;</td>
          <td class="paramname"><em>p_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an element at the current iterator location.</p>
<p>Inserts the new element at the position of the iterator, before the element the iterator is currently pointing at. The iterator will stay at the new entry, and will move to the same entry as it was on prior to the insertion on the next iteration.</p>
<p>Example of inserting node D (with the iterator location): </p><div class="fragment"><div class="line">Before:</div>
<div class="line"> A -&gt; B -&gt; C</div>
<div class="line">      ^it</div>
<div class="line">After:</div>
<div class="line"> A -&gt; D -&gt; B -&gt; C</div>
<div class="line">      ^it</div>
<div class="line">After next iterate:</div>
<div class="line"> A -&gt; D -&gt; B -&gt; C</div>
<div class="line">           ^it</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe. It should only be used on queues that operate in a single IRQ level.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_it</td><td>Iterator to insert an element at. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_elem</td><td>Element to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf6016887c7c7e3cc288f81893fc02c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf6016887c7c7e3cc288f81893fc02c9">&#9670;&nbsp;</a></span>queue_iterator_elem_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_iterator_elem_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>p_it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the element the iterator is at.</p>
<p>The iterator will be moved to the next element immediately, instead of being moved at the next iteration call. This allows the user to remove items in the middle of an iteration without skipping any elements:</p>
<div class="fragment"><div class="line"><a class="code" href="group___queue.html#ga721d59d18eb4ecd0e164992274f99729">QUEUE_FOREACH</a>(p_queue, it)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (should_delete_elem(&amp;it))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group___queue.html#gabf6016887c7c7e3cc288f81893fc02c9">queue_iterator_elem_remove</a>(&amp;it);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup___queue_html_ga721d59d18eb4ecd0e164992274f99729"><div class="ttname"><a href="group___queue.html#ga721d59d18eb4ecd0e164992274f99729">QUEUE_FOREACH</a></div><div class="ttdeci">#define QUEUE_FOREACH(p_QUEUE, ITERATOR)</div><div class="ttdef"><b>Definition:</b> util_queue.h:140</div></div>
<div class="ttc" id="agroup___queue_html_gabf6016887c7c7e3cc288f81893fc02c9"><div class="ttname"><a href="group___queue.html#gabf6016887c7c7e3cc288f81893fc02c9">queue_iterator_elem_remove</a></div><div class="ttdeci">void queue_iterator_elem_remove(queue_elem_iterator_t *p_it)</div></div>
</div><!-- fragment --><p>In this code snippet, the <code>should_delete_elem</code> call will be executed on every queue element, even though the <code>queue_iterator_elem_remove</code> call removes elements.</p>
<p>Example of removing node B (with the iterator location): </p><div class="fragment"><div class="line">Before:</div>
<div class="line"> A -&gt; B -&gt; C -&gt; D</div>
<div class="line">      ^it</div>
<div class="line">After:</div>
<div class="line"> A -&gt; C -&gt; D</div>
<div class="line">      ^it</div>
<div class="line">After next iterate:</div>
<div class="line"> A -&gt; C -&gt; D</div>
<div class="line">      ^it</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe. It should only be used on queues that operate in a single IRQ level.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_it</td><td>Iterator to remove element at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1560182acc41d1597f4f15c6b64d5413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1560182acc41d1597f4f15c6b64d5413">&#9670;&nbsp;</a></span>queue_iterator_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_iterator_iterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__elem__iterator__t.html">queue_elem_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>p_it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates to the next element.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe. It should only be used on queues that operate in a single IRQ level.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_it</td><td>Iterator to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d68de14bc06afa6ca37363b5451896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d68de14bc06afa6ca37363b5451896">&#9670;&nbsp;</a></span>queue_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>p_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>p_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops all elements of <code>p_src</code> and adds them at the end of <code>p_dst</code>.</p>
<p>After this operation, <code>p_dst</code> will contain all of its own elements (in their original order), then all the elements of <code>p_src</code> (in their original order). <code>p_src</code> will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_dst</td><td>Destination queue for all the elements. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_src</td><td>Source queue for all the elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d3c69b67db07c577a680294a7ee2a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3c69b67db07c577a680294a7ee2a58">&#9670;&nbsp;</a></span>queue_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqueue__elem.html">queue_elem_t</a>* queue_peek </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>p_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Peeks at the element at the front of the queue, but does not remove it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_queue</td><td>Queue instance to peek from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>p_data</code> pointer of the element at the front of the queue, or NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="ga246a80aa4f6bba745b2fe186f904020c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga246a80aa4f6bba745b2fe186f904020c">&#9670;&nbsp;</a></span>queue_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqueue__elem.html">queue_elem_t</a>* queue_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>p_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops the element at the front of the queue, and removes it from the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_queue</td><td>Queue instance to pop from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>p_data</code> pointer of the element at the front of the queue, or NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="gaf9f85aea4c49c1e0d9c63bd2801c9c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f85aea4c49c1e0d9c63bd2801c9c99">&#9670;&nbsp;</a></span>queue_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>p_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue__elem.html">queue_elem_t</a> *&#160;</td>
          <td class="paramname"><em>p_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a single queue element to the back of the given queue instance.</p>
<dl class="section warning"><dt>Warning</dt><dd>: The user has to set the <code>p_data</code> pointer to reference the desired data of the element before pushing it to the queue. This function will assert if <code>p_data</code> is NULL. The <code>p_data</code> member will never be changed by the queue module.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_queue</td><td>The queue instance to push to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_elem</td><td>Pointer to a statically allocated queue element to push to the back of the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
