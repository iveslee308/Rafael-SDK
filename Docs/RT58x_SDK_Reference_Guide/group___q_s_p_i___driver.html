<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rafael RT58x  SDK: QSPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.BMP"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rafael RT58x  SDK
   &#160;<span id="projectnumber">v1.9.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">QSPI</div>  </div>
</div><!--header-->
<div class="contents">

<p>QSPI Driver header information.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__transfer__mode__t.html">qspi_transfer_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqspi__transfer__mode__t.html" title="qspi_transfer_mode_t">qspi_transfer_mode_t</a>  <a href="structqspi__transfer__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqspi__block__request__t.html" title="qspi_block_request_t">qspi_block_request_t</a>  <a href="structqspi__block__request__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__block__request__t.html">spi_block_request_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structspi__block__request__t.html" title="spi_block_request_t">spi_block_request_t</a>  <a href="structspi__block__request__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9bf349083401e250c1173e886adb4713"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga9bf349083401e250c1173e886adb4713">QSPI_NORMAL_SPI</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9bf349083401e250c1173e886adb4713"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI/QSPI Constant Definitions.  <a href="group___q_s_p_i___driver.html#ga9bf349083401e250c1173e886adb4713">More...</a><br /></td></tr>
<tr class="separator:ga9bf349083401e250c1173e886adb4713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b050b1a8bd53f0f01bd8a27b97253d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gaf3b050b1a8bd53f0f01bd8a27b97253d">QSPI_DUAL_SPI</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gaf3b050b1a8bd53f0f01bd8a27b97253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020987794a6bc65133d1fc3bc684f792"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga020987794a6bc65133d1fc3bc684f792">QSPI_QUAD_SPI</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga020987794a6bc65133d1fc3bc684f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88760b56f0915c07ae016f19cdefe290"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga88760b56f0915c07ae016f19cdefe290">QSPI_CLK_32M</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ga88760b56f0915c07ae016f19cdefe290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e78a523eca99c4c6e1a3db7ea0405d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga8e78a523eca99c4c6e1a3db7ea0405d4">QSPI_CLK_16M</a>&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_16MHZ)</td></tr>
<tr class="separator:ga8e78a523eca99c4c6e1a3db7ea0405d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149dc915dc05bfab6183d0e2db31dece"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga149dc915dc05bfab6183d0e2db31dece">QSPI_CLK_8M</a>&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_8MHZ)</td></tr>
<tr class="separator:ga149dc915dc05bfab6183d0e2db31dece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ecca92026e8c0a0911422602f49da7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gaa3ecca92026e8c0a0911422602f49da7">QSPI_CLK_4M</a>&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_4MHZ)</td></tr>
<tr class="separator:gaa3ecca92026e8c0a0911422602f49da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afe9de86efdd140d8f98a67d3121d82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga8afe9de86efdd140d8f98a67d3121d82">QSPI_CLK_2M</a>&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_2MHZ)</td></tr>
<tr class="separator:ga8afe9de86efdd140d8f98a67d3121d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72d92afe024c742cdb1751f2417054c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gad72d92afe024c742cdb1751f2417054c">QSPI_CLK_1M</a>&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_1MHZ)</td></tr>
<tr class="separator:gad72d92afe024c742cdb1751f2417054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac885e1a54c37fd8fb047f83eba64a0d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gac885e1a54c37fd8fb047f83eba64a0d6">SPI_LSB_ORDER</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:gac885e1a54c37fd8fb047f83eba64a0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2a2d115de7de1fc29b4abb4b47f21f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gaee2a2d115de7de1fc29b4abb4b47f21f">SPI_MSB_ORDER</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:gaee2a2d115de7de1fc29b4abb4b47f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf056028bd5830e0c00950f37fed2170"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gabf056028bd5830e0c00950f37fed2170">SPI_SELECT_SLAVE_0</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:gabf056028bd5830e0c00950f37fed2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d467398a12924560cfe8c21bdfe67b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga0d467398a12924560cfe8c21bdfe67b4">SPI_SELECT_SLAVE_1</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga0d467398a12924560cfe8c21bdfe67b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5787fd5cdd27ef33f6eae63084edaf5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga5787fd5cdd27ef33f6eae63084edaf5d">SPI_SELECT_SLAVE_2</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:ga5787fd5cdd27ef33f6eae63084edaf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga502a7d63de23cb33d758b14c4675ee0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga502a7d63de23cb33d758b14c4675ee0d">SPI_SELECT_SLAVE_3</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="separator:ga502a7d63de23cb33d758b14c4675ee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba45af6ec4c1b50b7a8611296a95eb2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gaba45af6ec4c1b50b7a8611296a95eb2b">SPI_CHIPSEL_ACTIVE_LOW</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:gaba45af6ec4c1b50b7a8611296a95eb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cdb023db58e26bb246822959f179b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga49cdb023db58e26bb246822959f179b7">SPI_CHIPSEL_ACTIVE_HIGH</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga49cdb023db58e26bb246822959f179b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6937829c8e8c6b3907faed0da21faa6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga6937829c8e8c6b3907faed0da21faa6c">SPI_SLAVE_MODE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ga6937829c8e8c6b3907faed0da21faa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf98f1876f8d084f0136bf7e8c2f8d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gacaf98f1876f8d084f0136bf7e8c2f8d4">SPI_MASTER_MODE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:gacaf98f1876f8d084f0136bf7e8c2f8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7efccf4d6f98c19fc1aa9a367b5cdeee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga7efccf4d6f98c19fc1aa9a367b5cdeee">QSPI_STATE_UNINIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga7efccf4d6f98c19fc1aa9a367b5cdeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c9fef612e6cd9af289b41ba4416138"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gad2c9fef612e6cd9af289b41ba4416138">QSPI_STATE_IDLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gad2c9fef612e6cd9af289b41ba4416138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f3fbc079c7157951bbdb79e1bdca85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gab0f3fbc079c7157951bbdb79e1bdca85">QSPI_STATE_TRANSFER</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gab0f3fbc079c7157951bbdb79e1bdca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d69b50d1137ef3c1dc8d178516bba27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga2d69b50d1137ef3c1dc8d178516bba27">QSPI_STATE_SETUP</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga2d69b50d1137ef3c1dc8d178516bba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3bf339a08237561df6c6cc2a5930d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga5f3bf339a08237561df6c6cc2a5930d0">QSPI_STATE_WRITE_DMA</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga5f3bf339a08237561df6c6cc2a5930d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1213b0ebc36ad3a9b90f140339d63a49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga1213b0ebc36ad3a9b90f140339d63a49">QSPI_STATE_READ_DMA</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga1213b0ebc36ad3a9b90f140339d63a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae42691e4de130ae9463ebe25a7b03013"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a>) (uint32_t qspi_id, uint32_t status)</td></tr>
<tr class="memdesc:gae42691e4de130ae9463ebe25a7b03013"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI finish routine callback for user application.  <a href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">More...</a><br /></td></tr>
<tr class="separator:gae42691e4de130ae9463ebe25a7b03013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1ae1131e5b504290e2771f9eb407c48e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga1ae1131e5b504290e2771f9eb407c48e">qspi_init</a> (uint32_t qspi_id, const <a class="el" href="structqspi__transfer__mode__t.html">qspi_transfer_mode_t</a> *spi_mode)</td></tr>
<tr class="memdesc:ga1ae1131e5b504290e2771f9eb407c48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">initial QSPI controller function.  <a href="group___q_s_p_i___driver.html#ga1ae1131e5b504290e2771f9eb407c48e">More...</a><br /></td></tr>
<tr class="separator:ga1ae1131e5b504290e2771f9eb407c48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4663966d32a2cae589c71f1cbe6de6a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga4663966d32a2cae589c71f1cbe6de6a7">qspi_transfer</a> (uint32_t qspi_id, const <a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a> *req)</td></tr>
<tr class="memdesc:ga4663966d32a2cae589c71f1cbe6de6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI transfer function.  <a href="group___q_s_p_i___driver.html#ga4663966d32a2cae589c71f1cbe6de6a7">More...</a><br /></td></tr>
<tr class="separator:ga4663966d32a2cae589c71f1cbe6de6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97fff8045d0388838f78ad6864e65e1c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga97fff8045d0388838f78ad6864e65e1c">qspi_write_dma</a> (uint32_t qspi_id, const <a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a> *req, <a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a> finish_proc_cb)</td></tr>
<tr class="memdesc:ga97fff8045d0388838f78ad6864e65e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI transfer data to spi slave device by using DMA.  <a href="group___q_s_p_i___driver.html#ga97fff8045d0388838f78ad6864e65e1c">More...</a><br /></td></tr>
<tr class="separator:ga97fff8045d0388838f78ad6864e65e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39327a1759d43396b335b375784d147"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gad39327a1759d43396b335b375784d147">qspi_read_dma</a> (uint32_t qspi_id, const <a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a> *req, <a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a> finish_proc_cb)</td></tr>
<tr class="memdesc:gad39327a1759d43396b335b375784d147"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI read data from spi slave device by using DMA.  <a href="group___q_s_p_i___driver.html#gad39327a1759d43396b335b375784d147">More...</a><br /></td></tr>
<tr class="separator:gad39327a1759d43396b335b375784d147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a69197d7bad63e5b4c1dcdf7036d1dd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga8a69197d7bad63e5b4c1dcdf7036d1dd">spi_transfer</a> (uint32_t qspi_id, const <a class="el" href="structspi__block__request__t.html">spi_block_request_t</a> *req, <a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a> finish_proc_cb)</td></tr>
<tr class="memdesc:ga8a69197d7bad63e5b4c1dcdf7036d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transfer data.  <a href="group___q_s_p_i___driver.html#ga8a69197d7bad63e5b4c1dcdf7036d1dd">More...</a><br /></td></tr>
<tr class="separator:ga8a69197d7bad63e5b4c1dcdf7036d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e21c12ab0ce02c68a808d9f8849ead"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gac2e21c12ab0ce02c68a808d9f8849ead">spi_transfer_pio</a> (uint32_t qspi_id, const <a class="el" href="structspi__block__request__t.html">spi_block_request_t</a> *req)</td></tr>
<tr class="memdesc:gac2e21c12ab0ce02c68a808d9f8849ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transfer data by PIO.  <a href="group___q_s_p_i___driver.html#gac2e21c12ab0ce02c68a808d9f8849ead">More...</a><br /></td></tr>
<tr class="separator:gac2e21c12ab0ce02c68a808d9f8849ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7743ea3149ba3530561c33b82e20c47e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga7743ea3149ba3530561c33b82e20c47e">get_qspi_state</a> (uint32_t qspi_id)</td></tr>
<tr class="memdesc:ga7743ea3149ba3530561c33b82e20c47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPI controller state.  <a href="group___q_s_p_i___driver.html#ga7743ea3149ba3530561c33b82e20c47e">More...</a><br /></td></tr>
<tr class="separator:ga7743ea3149ba3530561c33b82e20c47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858b51e5f0a94f16b35e35a3682bb1c3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga858b51e5f0a94f16b35e35a3682bb1c3">spi_transfer_slave_abort</a> (uint32_t qspi_id)</td></tr>
<tr class="memdesc:ga858b51e5f0a94f16b35e35a3682bb1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">abort slave received DMA command.  <a href="group___q_s_p_i___driver.html#ga858b51e5f0a94f16b35e35a3682bb1c3">More...</a><br /></td></tr>
<tr class="separator:ga858b51e5f0a94f16b35e35a3682bb1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627550581f0f2326fb3df0364b6957f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga627550581f0f2326fb3df0364b6957f5">qspi_FIFO_clear</a> (uint32_t qspi_id)</td></tr>
<tr class="memdesc:ga627550581f0f2326fb3df0364b6957f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear FIFO buffer command.  <a href="group___q_s_p_i___driver.html#ga627550581f0f2326fb3df0364b6957f5">More...</a><br /></td></tr>
<tr class="separator:ga627550581f0f2326fb3df0364b6957f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae10812143b041a0500c4c0bc858365c3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gae10812143b041a0500c4c0bc858365c3">SPI_BIT_ORDER</a>: 1</td></tr>
<tr class="separator:gae10812143b041a0500c4c0bc858365c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0425dc7d90bfe294e59ec677cb7aef"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga2c0425dc7d90bfe294e59ec677cb7aef">SPI_CPOL</a>: 1</td></tr>
<tr class="separator:ga2c0425dc7d90bfe294e59ec677cb7aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35b8f6c8c67f10cc7c6c05c6eb16fca"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gaa35b8f6c8c67f10cc7c6c05c6eb16fca">SPI_CPHA</a>: 1</td></tr>
<tr class="separator:gaa35b8f6c8c67f10cc7c6c05c6eb16fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c2eb1ad414e954dc0f1996393aafbd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gae8c2eb1ad414e954dc0f1996393aafbd">SPI_CS</a>: 2</td></tr>
<tr class="separator:gae8c2eb1ad414e954dc0f1996393aafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f799b1b756b2064c26ed604314c29fa"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga2f799b1b756b2064c26ed604314c29fa">SPI_CS_POL</a>: 1</td></tr>
<tr class="separator:ga2f799b1b756b2064c26ed604314c29fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1505100953e23506ae3d1bc5a7c47a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga7d1505100953e23506ae3d1bc5a7c47a">SPI_MASTER</a>: 1</td></tr>
<tr class="separator:ga7d1505100953e23506ae3d1bc5a7c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcd66477fde2a108a623910f43fe6a4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga9fcd66477fde2a108a623910f43fe6a4">SPI_CLK</a></td></tr>
<tr class="separator:ga9fcd66477fde2a108a623910f43fe6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae622c98792de50444e276637fc5e221f"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gae622c98792de50444e276637fc5e221f">cmd_buf</a></td></tr>
<tr class="separator:gae622c98792de50444e276637fc5e221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573ceff564247b3e6899ed1180ab5805"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga573ceff564247b3e6899ed1180ab5805">write_buf</a></td></tr>
<tr class="separator:ga573ceff564247b3e6899ed1180ab5805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216ea4299e57182add726124d075ad5e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga216ea4299e57182add726124d075ad5e">read_buf</a></td></tr>
<tr class="separator:ga216ea4299e57182add726124d075ad5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf27cbb1a104aa8934a8c2a020e3f409"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#gadf27cbb1a104aa8934a8c2a020e3f409">cmd_length</a></td></tr>
<tr class="separator:gadf27cbb1a104aa8934a8c2a020e3f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbd74ffd208cc4e3be995927c1c6100"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga0bbd74ffd208cc4e3be995927c1c6100">write_length</a></td></tr>
<tr class="separator:ga0bbd74ffd208cc4e3be995927c1c6100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d8d56dede980ad1504251f8bda08e0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga09d8d56dede980ad1504251f8bda08e0">read_length</a></td></tr>
<tr class="separator:ga09d8d56dede980ad1504251f8bda08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a136fc7faea14da260ea6e4111d11f5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga0a136fc7faea14da260ea6e4111d11f5">data_transfer_mode</a>: 2</td></tr>
<tr class="separator:ga0a136fc7faea14da260ea6e4111d11f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573ceff564247b3e6899ed1180ab5805"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga573ceff564247b3e6899ed1180ab5805">write_buf</a></td></tr>
<tr class="separator:ga573ceff564247b3e6899ed1180ab5805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216ea4299e57182add726124d075ad5e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga216ea4299e57182add726124d075ad5e">read_buf</a></td></tr>
<tr class="separator:ga216ea4299e57182add726124d075ad5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1892eba2086d12ac2b09005aeb09ea3b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___driver.html#ga1892eba2086d12ac2b09005aeb09ea3b">length</a></td></tr>
<tr class="separator:ga1892eba2086d12ac2b09005aeb09ea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>QSPI Driver header information. </p>
<p>QSPI and SPI is the same hardware, the only difference is QSPI driver designed for Flash device.</p>
<p>QSPI flash has specific transfer protocol for read/write behavior. QSPI can use 1, 2, 4 data pins for transfer mode. This driver is master mode for QSPI-flash.</p>
<p>However, SPI device only has 2 data pins, MISO and MOSI. This driver can be master or slave for SPI device.</p>
<p>ONLY QSPI0 has 4 data pin data interface. QSPI1 is standard SPI inferface. So if there is one QSPI-flash device connected with the qspi port (QSPI0), then the qspi port should set master mode.</p>
<p>QSPI0 also supports multiple CS, if you want to use this option, please enable the define in project_config.h</p>
<p>#define SUPPORT_QSPI0_MULTI_CS 1</p>
<p>And if you enable this "SUPPORT_QSPI0_MULTI_CS" option, you should assign select_slave_device member for each spi/qspi request.</p>
<p>Notice: Only QSPI0 supports multiple chip-select. For QSPI1, select_slave_device must be SPI_SELECT_SLAVE_0. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8e78a523eca99c4c6e1a3db7ea0405d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e78a523eca99c4c6e1a3db7ea0405d4">&#9670;&nbsp;</a></span>QSPI_CLK_16M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_CLK_16M&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_16MHZ)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI running 16MHz <br  />
 </p>

</div>
</div>
<a id="gad72d92afe024c742cdb1751f2417054c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad72d92afe024c742cdb1751f2417054c">&#9670;&nbsp;</a></span>QSPI_CLK_1M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_CLK_1M&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_1MHZ)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI running 1MHz <br  />
 </p>

</div>
</div>
<a id="ga8afe9de86efdd140d8f98a67d3121d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8afe9de86efdd140d8f98a67d3121d82">&#9670;&nbsp;</a></span>QSPI_CLK_2M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_CLK_2M&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_2MHZ)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI running 2MHz <br  />
 </p>

</div>
</div>
<a id="ga88760b56f0915c07ae016f19cdefe290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88760b56f0915c07ae016f19cdefe290">&#9670;&nbsp;</a></span>QSPI_CLK_32M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_CLK_32M&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI running 32MHz <br  />
 </p>

</div>
</div>
<a id="gaa3ecca92026e8c0a0911422602f49da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ecca92026e8c0a0911422602f49da7">&#9670;&nbsp;</a></span>QSPI_CLK_4M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_CLK_4M&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_4MHZ)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI running 4MHz <br  />
 </p>

</div>
</div>
<a id="ga149dc915dc05bfab6183d0e2db31dece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149dc915dc05bfab6183d0e2db31dece">&#9670;&nbsp;</a></span>QSPI_CLK_8M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_CLK_8M&#160;&#160;&#160;(QSPI_MST_CLKDIV_EN|QSPI_MST_CLKDIV_8MHZ)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI running 8MHz <br  />
 </p>

</div>
</div>
<a id="gaf3b050b1a8bd53f0f01bd8a27b97253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b050b1a8bd53f0f01bd8a27b97253d">&#9670;&nbsp;</a></span>QSPI_DUAL_SPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_DUAL_SPI&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QSPI 2bits mode <br  />
 </p>

</div>
</div>
<a id="ga9bf349083401e250c1173e886adb4713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bf349083401e250c1173e886adb4713">&#9670;&nbsp;</a></span>QSPI_NORMAL_SPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_NORMAL_SPI&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI/QSPI Constant Definitions. </p>
<p>SPI normal mode <br  />
 </p>

</div>
</div>
<a id="ga020987794a6bc65133d1fc3bc684f792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020987794a6bc65133d1fc3bc684f792">&#9670;&nbsp;</a></span>QSPI_QUAD_SPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_QUAD_SPI&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QSPI 4bits mode <br  />
 </p>

</div>
</div>
<a id="gad2c9fef612e6cd9af289b41ba4416138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2c9fef612e6cd9af289b41ba4416138">&#9670;&nbsp;</a></span>QSPI_STATE_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_STATE_IDLE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller in idle state. <br  />
 </p>

</div>
</div>
<a id="ga1213b0ebc36ad3a9b90f140339d63a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1213b0ebc36ad3a9b90f140339d63a49">&#9670;&nbsp;</a></span>QSPI_STATE_READ_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_STATE_READ_DMA&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller in DMA write/read transfer state. <br  />
 </p>

</div>
</div>
<a id="ga2d69b50d1137ef3c1dc8d178516bba27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d69b50d1137ef3c1dc8d178516bba27">&#9670;&nbsp;</a></span>QSPI_STATE_SETUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_STATE_SETUP&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller in setting controller state. <br  />
 </p>

</div>
</div>
<a id="gab0f3fbc079c7157951bbdb79e1bdca85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f3fbc079c7157951bbdb79e1bdca85">&#9670;&nbsp;</a></span>QSPI_STATE_TRANSFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_STATE_TRANSFER&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller in CPU transfer state. <br  />
 </p>

</div>
</div>
<a id="ga7efccf4d6f98c19fc1aa9a367b5cdeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7efccf4d6f98c19fc1aa9a367b5cdeee">&#9670;&nbsp;</a></span>QSPI_STATE_UNINIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_STATE_UNINIT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@Brief SPI operation state return Constant Definitions SPI controller in uninitial state. <br  />
 </p>

</div>
</div>
<a id="ga5f3bf339a08237561df6c6cc2a5930d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3bf339a08237561df6c6cc2a5930d0">&#9670;&nbsp;</a></span>QSPI_STATE_WRITE_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSPI_STATE_WRITE_DMA&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller in DMA write (TX only) transfer state. <br  />
 </p>

</div>
</div>
<a id="ga49cdb023db58e26bb246822959f179b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49cdb023db58e26bb246822959f179b7">&#9670;&nbsp;</a></span>SPI_CHIPSEL_ACTIVE_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_CHIPSEL_ACTIVE_HIGH&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Active high for Chip Select,slave selected in CS in high <br  />
 </p>

</div>
</div>
<a id="gaba45af6ec4c1b50b7a8611296a95eb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba45af6ec4c1b50b7a8611296a95eb2b">&#9670;&nbsp;</a></span>SPI_CHIPSEL_ACTIVE_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_CHIPSEL_ACTIVE_LOW&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Active low for Chip Select, slave selected in CS in low <br  />
 </p>

</div>
</div>
<a id="gac885e1a54c37fd8fb047f83eba64a0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac885e1a54c37fd8fb047f83eba64a0d6">&#9670;&nbsp;</a></span>SPI_LSB_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_LSB_ORDER&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI Least significant bit shifted out first. <br  />
 </p>

</div>
</div>
<a id="gacaf98f1876f8d084f0136bf7e8c2f8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaf98f1876f8d084f0136bf7e8c2f8d4">&#9670;&nbsp;</a></span>SPI_MASTER_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_MASTER_MODE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller will be set as master mode. <br  />
 </p>

</div>
</div>
<a id="gaee2a2d115de7de1fc29b4abb4b47f21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2a2d115de7de1fc29b4abb4b47f21f">&#9670;&nbsp;</a></span>SPI_MSB_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_MSB_ORDER&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI Most significant bit shifted out first. <br  />
 </p>

</div>
</div>
<a id="gabf056028bd5830e0c00950f37fed2170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf056028bd5830e0c00950f37fed2170">&#9670;&nbsp;</a></span>SPI_SELECT_SLAVE_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SELECT_SLAVE_0&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select Slave 0 <br  />
 </p>

</div>
</div>
<a id="ga0d467398a12924560cfe8c21bdfe67b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d467398a12924560cfe8c21bdfe67b4">&#9670;&nbsp;</a></span>SPI_SELECT_SLAVE_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SELECT_SLAVE_1&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select Slave 1 <br  />
 </p>

</div>
</div>
<a id="ga5787fd5cdd27ef33f6eae63084edaf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5787fd5cdd27ef33f6eae63084edaf5d">&#9670;&nbsp;</a></span>SPI_SELECT_SLAVE_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SELECT_SLAVE_2&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select Slave 2 <br  />
 </p>

</div>
</div>
<a id="ga502a7d63de23cb33d758b14c4675ee0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga502a7d63de23cb33d758b14c4675ee0d">&#9670;&nbsp;</a></span>SPI_SELECT_SLAVE_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SELECT_SLAVE_3&#160;&#160;&#160;(3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select Slave 3 <br  />
 </p>

</div>
</div>
<a id="ga6937829c8e8c6b3907faed0da21faa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6937829c8e8c6b3907faed0da21faa6c">&#9670;&nbsp;</a></span>SPI_SLAVE_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SLAVE_MODE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI controller will be set as slave mode. <br  />
 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gae42691e4de130ae9463ebe25a7b03013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42691e4de130ae9463ebe25a7b03013">&#9670;&nbsp;</a></span>qspi_proc_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* qspi_proc_cb_t) (uint32_t qspi_id, uint32_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI finish routine callback for user application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qspi_id</td><td>QSPI id. 0 for QSPI0, 1 for QSPI 1</td></tr>
    <tr><td class="paramname">statue</td><td>QSPI transfer status.</td></tr>
  </table>
  </dd>
</dl>
<p>status is always QSPI_STATUS_TRANSFER_COMPLETE </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7743ea3149ba3530561c33b82e20c47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7743ea3149ba3530561c33b82e20c47e">&#9670;&nbsp;</a></span>get_qspi_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_qspi_state </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPI controller state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">QSPI_STATE_UNINIT</td><td></td></tr>
    <tr><td class="paramname">QSPI_STATE_IDLE</td><td></td></tr>
    <tr><td class="paramname">QSPI_STATE_SETUP</td><td></td></tr>
    <tr><td class="paramname">QSPI_STATE_TRANSFER</td><td></td></tr>
    <tr><td class="paramname">QSPI_STATE_WRITE_DMA</td><td></td></tr>
    <tr><td class="paramname">QSPI_STATE_READ_DMA</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This function will return current controller operation state. </p>

</div>
</div>
<a id="ga627550581f0f2326fb3df0364b6957f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627550581f0f2326fb3df0364b6957f5">&#9670;&nbsp;</a></span>qspi_FIFO_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qspi_FIFO_clear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear FIFO buffer command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will clear the qspi FIFO buffer command... </p>

</div>
</div>
<a id="ga1ae1131e5b504290e2771f9eb407c48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ae1131e5b504290e2771f9eb407c48e">&#9670;&nbsp;</a></span>qspi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structqspi__transfer__mode__t.html">qspi_transfer_mode_t</a> *&#160;</td>
          <td class="paramname"><em>spi_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initial QSPI controller function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi_mode</td><td>Specifies the controller transfer operation mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_ERROR</td><td>&mdash; This controller is in busying state for transfer </td></tr>
    <tr><td class="paramname">STATUS_INVALID_PARAM</td><td>&mdash; Wrong parameter </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>&mdash; This controller setting is successful</td></tr>
  </table>
  </dd>
</dl>
<p>If there is only one spi device connected SPI0(QSPI0), then the "select polarity" set in parameter spi_mode-&gt;SPI_CS_POL, and the chip select is set in parameter spi_mode-&gt;SPI_CS by default. Then each data transfer, system will using these settings to transfer. </p>

</div>
</div>
<a id="gad39327a1759d43396b335b375784d147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad39327a1759d43396b335b375784d147">&#9670;&nbsp;</a></span>qspi_read_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_read_dma </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a>&#160;</td>
          <td class="paramname"><em>finish_proc_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI read data from spi slave device by using DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Specifies the transfer request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finish_proc_cb</td><td>Specifies the interrupt ISR callback function when read data request completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_INVALID_REQUEST</td><td>QSPI Master is busy for previous tranfer request.. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>This request is in progressing...</td></tr>
  </table>
  </dd>
</dl>
<p>qspi_read_dma function is only for QSPI master only.</p>
<p>This function designed for read data from QSPI flash device, like QSPI flash command 0x3B/0x6B/0x0B. In QSPI flash command, there is only two phase for "read command", command phase and read data phase. Fill QSPI command to command buffer, and set write data to NULL. And set read_buf to pointer of receied data. This function is non-block function, that is, when this function reutrns, it just means the operation is start in progressing.... when the request finishs, the notify callback function "finish_proc_cb" will be called </p>
<p>4N case</p>

</div>
</div>
<a id="ga4663966d32a2cae589c71f1cbe6de6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4663966d32a2cae589c71f1cbe6de6a7">&#9670;&nbsp;</a></span>qspi_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_transfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI transfer function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Specifies the transfer request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_INVALID_REQUEST</td><td>SPI controller is busy or uninitial. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>SPI transfer complete</td></tr>
  </table>
  </dd>
</dl>
<p>QSPI is master mode only. This function is using PIO (program I/O mode), that is, using cpu to move data between ram and spi FIFO.</p>
<p>qspi_flash_block_request_t request buffer start address must be 4-bytes alignment. (Because the transfer will use 32-Bit transfer mode)!</p>
<p>Please do NOT call qspi_transfer function in ISR. Because this function is BLOCK function. It returns after the request finish. </p>

</div>
</div>
<a id="ga97fff8045d0388838f78ad6864e65e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97fff8045d0388838f78ad6864e65e1c">&#9670;&nbsp;</a></span>qspi_write_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_write_dma </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structqspi__block__request__t.html">qspi_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a>&#160;</td>
          <td class="paramname"><em>finish_proc_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI transfer data to spi slave device by using DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Specifies the transfer request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finish_proc_cb</td><td>Specifies the interrupt ISR callback function when write data request completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_INVALID_REQUEST</td><td>&mdash; QSPI Master is busy for previous tranfer request.. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>&mdash; This request is in progressing...</td></tr>
  </table>
  </dd>
</dl>
<p>qspi_write_dma function is only for QSPI master only.</p>
<p>This function designed for write data to QSPI flash device, like QSPI flash command 0x32/0x02. In QSPI flash command, there is only two phase for "write command", command phase and write data phase. Fill QSPI command to command buffer, and fill write data to write_buf. And set read_buf to NULL. This function is non-block function, that is, when this function reutrns, it just means the operation is start in progressing.... when the request finishs, the notify callback function "finish_proc_cb" will be called </p>
<p>4N case</p>

</div>
</div>
<a id="ga8a69197d7bad63e5b4c1dcdf7036d1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a69197d7bad63e5b4c1dcdf7036d1dd">&#9670;&nbsp;</a></span>spi_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spi_transfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspi__block__request__t.html">spi_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i___driver.html#gae42691e4de130ae9463ebe25a7b03013">qspi_proc_cb_t</a>&#160;</td>
          <td class="paramname"><em>finish_proc_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transfer data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Specifies the <a class="el" href="structspi__block__request__t.html" title="spi_block_request_t">spi_block_request_t</a> transfer request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finish_proc_cb</td><td>Specifies the interrupt ISR callback function when transfer data completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_INVALID_REQUEST</td><td>&mdash; SPI controller is busy for previous tranfer request.. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>&mdash; This request is in progressing...</td></tr>
  </table>
  </dd>
</dl>
<p>The function spi_transfer transfers data via SPI by using DMA to transfer. It synchronously sends data to the SPI transmitter and receives data from the SPI receiver.</p>
<p>The parameter <a class="el" href="structspi__block__request__t.html" title="spi_block_request_t">spi_block_request_t</a> is the data structure of transfer data, it includes: write_buf is a pointer to the buffer with data to send. read_buf is a pointer to the buffer which receives data. length specifies the number of "bytes" to transfer.</p>
<p>The transfer length should be less than 65536 bytes.</p>
<p>Calling the function spi_transfer only starts the transfer operation. The function is non-blocking and returns as soon as the driver has started the operation (driver will configures DMA for continuous transfer).</p>
<p>When in slave mode, the operation is only registered and started when the master starts the transfer.</p>
<p>During the operation it is not allowed to call this function or any other data transfer function again. Also the data buffers must stay allocated and the contents of unsent data must not be modified.</p>
<p>When transfer operation is completed (requested number of items transferred), the callback function will be called to notify finish. </p>

</div>
</div>
<a id="gac2e21c12ab0ce02c68a808d9f8849ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e21c12ab0ce02c68a808d9f8849ead">&#9670;&nbsp;</a></span>spi_transfer_pio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spi_transfer_pio </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspi__block__request__t.html">spi_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transfer data by PIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Specifies the <a class="el" href="structspi__block__request__t.html" title="spi_block_request_t">spi_block_request_t</a> transfer request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_INVALID_REQUEST</td><td>&mdash; SPI controller is busy for previous tranfer request.. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>&mdash; This request is in progressing...</td></tr>
  </table>
  </dd>
</dl>
<p>The function spi_transfer_pio transfers data via SPI by Programming I/O mode. That is, this function uses CPU to move data to spi FIFO. This function is blocking function, it returns when all data transfer complete. This function is useful for short command data transfer.</p>
<p>Please do NOT　call this function if SPI is in slave mode, because it can not predict when time host will send data to device. CPU busy waiting for unpredictable event is not a good design.</p>
<p>The parameter <a class="el" href="structspi__block__request__t.html" title="spi_block_request_t">spi_block_request_t</a> is the data structure of transfer data, it includes: write_buf is a pointer to the buffer with data to send. read_buf is a pointer to the buffer which receives data. length specifies the number of "bytes" to transfer.</p>
<p>If SPI master wants to send data to and receive data from slave at the same time, the transfer length should be less than or equal 32 bytes. If SPI master only wants to send data to spi slave, the transfer length there is no limit for transfer length size. But busying wait SPI transfer complete will waste CPU resource. Please do NOT call this function in interrupt ISR, </p>

</div>
</div>
<a id="ga858b51e5f0a94f16b35e35a3682bb1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga858b51e5f0a94f16b35e35a3682bb1c3">&#9670;&nbsp;</a></span>spi_transfer_slave_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spi_transfer_slave_abort </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qspi_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>abort slave received DMA command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qspi_id</td><td>Specifies the controller id. 0 for QSPI0/ 1 for QSPI1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_SUCCESS</td><td></td></tr>
    <tr><td class="paramname">STATUS_INVALID_REQUEST</td><td>&mdash; this function can not abort SPI master</td></tr>
  </table>
  </dd>
</dl>
<p>This function will abort the qspi slave send/receive command... Because we don't know which time host will send data to SPI slave... we start dma request to wait SPI host command, but for some reason, we should terminate to wait the request. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae622c98792de50444e276637fc5e221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae622c98792de50444e276637fc5e221f">&#9670;&nbsp;</a></span>cmd_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* cmd_buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to command buffer for QSPI transfer, it must be 4 bytes alignment <br  />
 </p>

</div>
</div>
<a id="gadf27cbb1a104aa8934a8c2a020e3f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf27cbb1a104aa8934a8c2a020e3f409">&#9670;&nbsp;</a></span>cmd_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t cmd_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>command buffer length for QSPI transfer <br  />
 </p>

</div>
</div>
<a id="ga0a136fc7faea14da260ea6e4111d11f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a136fc7faea14da260ea6e4111d11f5">&#9670;&nbsp;</a></span>data_transfer_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t data_transfer_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QSPI_NORMAL_SPI / QSPI_DUAL_SPI / QSPI_QUAD_SPI <br  />
 </p>

</div>
</div>
<a id="ga1892eba2086d12ac2b09005aeb09ea3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1892eba2086d12ac2b09005aeb09ea3b">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>transfer length. </p>

</div>
</div>
<a id="ga216ea4299e57182add726124d075ad5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216ea4299e57182add726124d075ad5e">&#9670;&nbsp;</a></span>read_buf <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* read_buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to read buffer for QSPI transfer, host will receive data from slave device. It must be 4 bytes alignment <br  />
 </p>

</div>
</div>
<a id="ga216ea4299e57182add726124d075ad5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216ea4299e57182add726124d075ad5e">&#9670;&nbsp;</a></span>read_buf <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* read_buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to RX buffer for SPI transfer, it could be NULL for TX only. <br  />
 </p>

</div>
</div>
<a id="ga09d8d56dede980ad1504251f8bda08e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d8d56dede980ad1504251f8bda08e0">&#9670;&nbsp;</a></span>read_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t read_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read buffer length for data to receive from spi slave device <br  />
 </p>

</div>
</div>
<a id="gae10812143b041a0500c4c0bc858365c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae10812143b041a0500c4c0bc858365c3">&#9670;&nbsp;</a></span>SPI_BIT_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_BIT_ORDER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI_LSB_ORDER or SPI_MSB_ORDER <br  />
 </p>

</div>
</div>
<a id="ga9fcd66477fde2a108a623910f43fe6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fcd66477fde2a108a623910f43fe6a4">&#9670;&nbsp;</a></span>SPI_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t SPI_CLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For host mode, the controller will output CLK by this setting. For slave mode, this value will be ignored <br  />
 </p>

</div>
</div>
<a id="gaa35b8f6c8c67f10cc7c6c05c6eb16fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa35b8f6c8c67f10cc7c6c05c6eb16fca">&#9670;&nbsp;</a></span>SPI_CPHA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_CPHA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for SPI data sample timing in CLK low or high <br  />
 </p>

</div>
</div>
<a id="ga2c0425dc7d90bfe294e59ec677cb7aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c0425dc7d90bfe294e59ec677cb7aef">&#9670;&nbsp;</a></span>SPI_CPOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_CPOL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for SPI CLK active low or active high <br  />
 </p>

</div>
</div>
<a id="gae8c2eb1ad414e954dc0f1996393aafbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8c2eb1ad414e954dc0f1996393aafbd">&#9670;&nbsp;</a></span>SPI_CS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_CS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For SPI0 master mode, controller can select 4 slave devices to send SPI signal <br  />
 </p>

</div>
</div>
<a id="ga2f799b1b756b2064c26ed604314c29fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f799b1b756b2064c26ed604314c29fa">&#9670;&nbsp;</a></span>SPI_CS_POL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_CS_POL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chip select is active high or active low in operation. SPI_CHIPSEL_ACTIVE_LOW or SPI_CHIPSEL_ACTIVE_HIGH <br  />
 </p>

</div>
</div>
<a id="ga7d1505100953e23506ae3d1bc5a7c47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d1505100953e23506ae3d1bc5a7c47a">&#9670;&nbsp;</a></span>SPI_MASTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_MASTER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select for SPI_MASTER_MODE or SPI_SLAVE_MODE </p>

</div>
</div>
<a id="ga573ceff564247b3e6899ed1180ab5805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573ceff564247b3e6899ed1180ab5805">&#9670;&nbsp;</a></span>write_buf <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* write_buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to write buffer for QSPI transfer, host will send this buffter to spi slave device. It must be 4 bytes alignment <br  />
 </p>

</div>
</div>
<a id="ga573ceff564247b3e6899ed1180ab5805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573ceff564247b3e6899ed1180ab5805">&#9670;&nbsp;</a></span>write_buf <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* write_buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to TX buffer for SPI transfer, it could be NULL for RX only. <br  />
 </p>

</div>
</div>
<a id="ga0bbd74ffd208cc4e3be995927c1c6100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bbd74ffd208cc4e3be995927c1c6100">&#9670;&nbsp;</a></span>write_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t write_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>write buffer length for data to send to spi slave device. <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
