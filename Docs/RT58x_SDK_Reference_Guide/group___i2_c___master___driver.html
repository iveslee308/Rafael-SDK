<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rafael RT58x  SDK: I2C_Master</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.BMP"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rafael RT58x  SDK
   &#160;<span id="projectnumber">v1.9.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">I2C_Master</div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C_Master Driver header information.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__slave__data__t.html">i2c_slave_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the I2C transfer request.  <a href="structi2c__slave__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf9cc3bbd77725970692491eefe1efe12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#gaf9cc3bbd77725970692491eefe1efe12">I2C_CLOCK_800K</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:gaf9cc3bbd77725970692491eefe1efe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5aebafed01d2bbd0e4ac0f9e0c79d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga7e5aebafed01d2bbd0e4ac0f9e0c79d1">I2C_CLOCK_400K</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga7e5aebafed01d2bbd0e4ac0f9e0c79d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e286778b018646658893d373484d2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#gaf3e286778b018646658893d373484d2b">I2C_CLOCK_200K</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gaf3e286778b018646658893d373484d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13e59dd9fbef7ba00fa1fbf4970df9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#gae13e59dd9fbef7ba00fa1fbf4970df9a">I2C_CLOCK_100K</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gae13e59dd9fbef7ba00fa1fbf4970df9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f89ecbd5a354e5fc1156683619b1706"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga6f89ecbd5a354e5fc1156683619b1706">I2C_STATUS_OK</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga6f89ecbd5a354e5fc1156683619b1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dfb2cc0df2c7c61fce3716da35b9ba1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga3dfb2cc0df2c7c61fce3716da35b9ba1">I2C_STATUS_ERR_NOACK</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga3dfb2cc0df2c7c61fce3716da35b9ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga89d00f5233fa01e53ccbfd36d8c57cb2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga89d00f5233fa01e53ccbfd36d8c57cb2">i2cm_proc_cb_t</a>) (uint32_t status)</td></tr>
<tr class="memdesc:ga89d00f5233fa01e53ccbfd36d8c57cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C finish routine notify callback for user application.  <a href="group___i2_c___master___driver.html#ga89d00f5233fa01e53ccbfd36d8c57cb2">More...</a><br /></td></tr>
<tr class="separator:ga89d00f5233fa01e53ccbfd36d8c57cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad65d8f36296adbcc7023e9cc677b585b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#gad65d8f36296adbcc7023e9cc677b585b">i2c_preinit</a> (uint32_t SCL_pin, uint32_t SDA_pin)</td></tr>
<tr class="memdesc:gad65d8f36296adbcc7023e9cc677b585b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master pre-initial function.  <a href="group___i2_c___master___driver.html#gad65d8f36296adbcc7023e9cc677b585b">More...</a><br /></td></tr>
<tr class="separator:gad65d8f36296adbcc7023e9cc677b585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b8748f3c3df0c03e2a277e227ea4ce"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#gac5b8748f3c3df0c03e2a277e227ea4ce">i2c_init</a> (uint32_t I2C_SPEED)</td></tr>
<tr class="memdesc:gac5b8748f3c3df0c03e2a277e227ea4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C master initialize.  <a href="group___i2_c___master___driver.html#gac5b8748f3c3df0c03e2a277e227ea4ce">More...</a><br /></td></tr>
<tr class="separator:gac5b8748f3c3df0c03e2a277e227ea4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9a3fa5c4f9cd393e8a4c76ef918307"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga2b9a3fa5c4f9cd393e8a4c76ef918307">i2c_write</a> (const <a class="el" href="structi2c__slave__data__t.html">i2c_slave_data_t</a> *slave, uint8_t *data, uint32_t len, <a class="el" href="group___i2_c___master___driver.html#ga89d00f5233fa01e53ccbfd36d8c57cb2">i2cm_proc_cb_t</a> endproc_cb)</td></tr>
<tr class="memdesc:ga2b9a3fa5c4f9cd393e8a4c76ef918307"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C write data to slave.  <a href="group___i2_c___master___driver.html#ga2b9a3fa5c4f9cd393e8a4c76ef918307">More...</a><br /></td></tr>
<tr class="separator:ga2b9a3fa5c4f9cd393e8a4c76ef918307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3afa5f80d6595238a0d3f94e6019c6e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#gae3afa5f80d6595238a0d3f94e6019c6e">i2c_read</a> (const <a class="el" href="structi2c__slave__data__t.html">i2c_slave_data_t</a> *slave, uint8_t *data, uint32_t len, <a class="el" href="group___i2_c___master___driver.html#ga89d00f5233fa01e53ccbfd36d8c57cb2">i2cm_proc_cb_t</a> endproc_cb)</td></tr>
<tr class="memdesc:gae3afa5f80d6595238a0d3f94e6019c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C read data from slave.  <a href="group___i2_c___master___driver.html#gae3afa5f80d6595238a0d3f94e6019c6e">More...</a><br /></td></tr>
<tr class="separator:gae3afa5f80d6595238a0d3f94e6019c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1997a5306d6d04a9ce867303d1a6d9e1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga1997a5306d6d04a9ce867303d1a6d9e1">dev_addr</a></td></tr>
<tr class="separator:ga1997a5306d6d04a9ce867303d1a6d9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080256ea09f1cb7aaff2f61cfe9f2660"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga080256ea09f1cb7aaff2f61cfe9f2660">bFlag_16bits</a></td></tr>
<tr class="separator:ga080256ea09f1cb7aaff2f61cfe9f2660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0141879e2234dc89312b627b458f6353"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___master___driver.html#ga0141879e2234dc89312b627b458f6353">reg_addr</a></td></tr>
<tr class="separator:ga0141879e2234dc89312b627b458f6353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C_Master Driver header information. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae13e59dd9fbef7ba00fa1fbf4970df9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13e59dd9fbef7ba00fa1fbf4970df9a">&#9670;&nbsp;</a></span>I2C_CLOCK_100K</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLOCK_100K&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Master running in 100KHz <br  />
 </p>

</div>
</div>
<a id="gaf3e286778b018646658893d373484d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3e286778b018646658893d373484d2b">&#9670;&nbsp;</a></span>I2C_CLOCK_200K</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLOCK_200K&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Master running in 200KHz <br  />
 </p>

</div>
</div>
<a id="ga7e5aebafed01d2bbd0e4ac0f9e0c79d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e5aebafed01d2bbd0e4ac0f9e0c79d1">&#9670;&nbsp;</a></span>I2C_CLOCK_400K</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLOCK_400K&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Master running in 400KHz <br  />
 </p>

</div>
</div>
<a id="gaf9cc3bbd77725970692491eefe1efe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9cc3bbd77725970692491eefe1efe12">&#9670;&nbsp;</a></span>I2C_CLOCK_800K</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLOCK_800K&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@Brief I2C CLOCK Constant Definitions I2C Master running in 800KHz <br  />
 </p>

</div>
</div>
<a id="ga3dfb2cc0df2c7c61fce3716da35b9ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dfb2cc0df2c7c61fce3716da35b9ba1">&#9670;&nbsp;</a></span>I2C_STATUS_ERR_NOACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_ERR_NOACK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C command return ERR NOACK </p>

</div>
</div>
<a id="ga6f89ecbd5a354e5fc1156683619b1706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f89ecbd5a354e5fc1156683619b1706">&#9670;&nbsp;</a></span>I2C_STATUS_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_OK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@Brief I2C Master return ERROR Constant Definitions I2C command return SUCCESS <br  />
 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga89d00f5233fa01e53ccbfd36d8c57cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d00f5233fa01e53ccbfd36d8c57cb2">&#9670;&nbsp;</a></span>i2cm_proc_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* i2cm_proc_cb_t) (uint32_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C finish routine notify callback for user application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">statue</td><td>I2C transfer status. It must be I2C_STATUS_OK or I2C_STATUS_ERR_NOACK.</td></tr>
  </table>
  </dd>
</dl>
<p>This callback function is still running in interrupt mode, so this function should be as short as possible. It can NOT call any block function in this callback service routine.</p>
<p>This function will be called when I2C master finished the i2c transfer request, or when there is no ACK during the transfer (error case). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac5b8748f3c3df0c03e2a277e227ea4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b8748f3c3df0c03e2a277e227ea4ce">&#9670;&nbsp;</a></span>i2c_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t i2c_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>I2C_SPEED</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C master initialize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_SPEED</td><td>Set the I2C master bus clock frequency</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_SUCCESS</td><td>&mdash; I2C master initial success. STATUS_INVALID_REQUEST &mdash; I2C master is not in idle mode.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to initail I2C master, this function like "driver open" function. </p>

</div>
</div>
<a id="gad65d8f36296adbcc7023e9cc677b585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65d8f36296adbcc7023e9cc677b585b">&#9670;&nbsp;</a></span>i2c_preinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t i2c_preinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SCL_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SDA_pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C master pre-initial function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SCL_pin</td><td>Specifies the SCL pin number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SDA_pin</td><td>Specifies the SDA pin number.</td></tr>
  </table>
  </dd>
</dl>
<p>It is possible that previous i2c transfer uncomplete because of reset or any hardware reason. For this case, I2C device needs extra 9 SCL clock to reset itself default state. So the first time after booting, MCU will send 9 SCL clock to reset i2c device.</p>
<p>SCL_pin is SCL pin number. Only pin18, pin20, or pin22 is correct setting pin. SDA_pin is SDA pin number. Only pin19, pin21, or pin23 is correct setting pin.</p>
<p>This function also will set the pin as open drain mode. So if system want to enter deeply sleep mode, it should turn these pins to input mode again. </p>

</div>
</div>
<a id="gae3afa5f80d6595238a0d3f94e6019c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3afa5f80d6595238a0d3f94e6019c6e">&#9670;&nbsp;</a></span>i2c_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t i2c_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi2c__slave__data__t.html">i2c_slave_data_t</a> *&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___master___driver.html#ga89d00f5233fa01e53ccbfd36d8c57cb2">i2cm_proc_cb_t</a>&#160;</td>
          <td class="paramname"><em>endproc_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C read data from slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slave</td><td>Specifies the I2C slave address and register address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to buffer with data to receive from I2C slave. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of data bytes to receive, maxmum size is 1024 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endproc_cb</td><td>Specifies the interrupt ISR callback function when I2C request completed or aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C transfer status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_EBUSY</td><td>I2C Master is busy for previous tranfer request.. </td></tr>
    <tr><td class="paramname">STATUS_NO_INIT</td><td>I2C Master does NOT initial, pleae call i2c_init before this request. </td></tr>
    <tr><td class="paramname">STATUS_INVALID_PARAM</td><td>receive data size is too large. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>This request is in progressing...</td></tr>
  </table>
  </dd>
</dl>
<p>Notice: This function is non-blocking and returns as soon as the driver has started the request. During the operation it not allowed to call any I2C Master function again. Also the data buffer must stay allocated. When request has finished, the callback function "endproc_cb" will be called with parameter I2C_STATUS_OK.</p>
<p>The request is aborted in the following case: selected slave has not acknowledged the address. bus error has been detected. If aborted event happened, he callback function "endproc_cb" will be called with parameter I2C_STATUS_ERR_NOACK.</p>
<p>It is possible that multi-task to call this function at the same time in multitask OS. Only one request can be served. So caller should check return value. If return value is STATUS_EBUSY, caller should wait a period and then retry the request. </p>

</div>
</div>
<a id="ga2b9a3fa5c4f9cd393e8a4c76ef918307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b9a3fa5c4f9cd393e8a4c76ef918307">&#9670;&nbsp;</a></span>i2c_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t i2c_write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi2c__slave__data__t.html">i2c_slave_data_t</a> *&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___master___driver.html#ga89d00f5233fa01e53ccbfd36d8c57cb2">i2cm_proc_cb_t</a>&#160;</td>
          <td class="paramname"><em>endproc_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C write data to slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slave</td><td>Specifies the I2C slave address and register address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to buffer with data to write to I2C slave. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of data bytes to transmit, maxmum size is 1024 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endproc_cb</td><td>Specifies the interrupt ISR callback function when I2C request completed or aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C transfer status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_EBUSY</td><td>I2C Master is busy for previous tranfer request.. </td></tr>
    <tr><td class="paramname">STATUS_NO_INIT</td><td>I2C Master does NOT initial, pleae call i2c_init before this request. </td></tr>
    <tr><td class="paramname">STATUS_INVALID_PARAM</td><td>Transfer data size is too large. </td></tr>
    <tr><td class="paramname">STATUS_SUCCESS</td><td>This request is in progressing...</td></tr>
  </table>
  </dd>
</dl>
<p>Notice: This function is non-blocking and returns as soon as the driver has started the request. During the operation it not allowed to call any I2C Master function again. Also the data buffer must stay allocated and the contents of data must not be modified. When request has finished, the callback function "endproc_cb" will be called with parameter I2C_STATUS_OK.</p>
<p>The request is aborted in the following case: selected slave has not acknowledged the address. bus error has been detected. If aborted event happened, he callback function "endproc_cb" will be called with parameter I2C_STATUS_ERR_NOACK.</p>
<p>It is possible that multi-task to call this function at the same time in multitask OS. Only one request can be served. So caller should check return value. If return value is STATUS_EBUSY, caller should wait a period and then retry the request. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga080256ea09f1cb7aaff2f61cfe9f2660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga080256ea09f1cb7aaff2f61cfe9f2660">&#9670;&nbsp;</a></span>bFlag_16bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bFlag_16bits</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1 for register address is 16bits, 0 for register address is 8bits. <br  />
 </p>

</div>
</div>
<a id="ga1997a5306d6d04a9ce867303d1a6d9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1997a5306d6d04a9ce867303d1a6d9e1">&#9670;&nbsp;</a></span>dev_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t dev_addr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C device address, 7bits only <br  />
 </p>

</div>
</div>
<a id="ga0141879e2234dc89312b627b458f6353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0141879e2234dc89312b627b458f6353">&#9670;&nbsp;</a></span>reg_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t reg_addr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C register address value <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
